---
layout: post
title:  "SPA设计与架构"
date:   2017-09-28 01:21:03
categories: 读书笔记
---

> 介绍SPA应用中，各部分的协同运作以及测试和任务自动化

# 单页面导航

## 客户端路由器的概念

- 传统导航 - 导航是以*整个页面*为单位进行的，每次显示新的内容，都执行一次*完整的html页面刷新*
- SPA导航 - 通过*客户端路由器*监听URL的变化，与*配置项*进行匹配后，借助*动态加载等*技术手段，从服务端获取*数据和模板*，动态的刷新页面*DOM中的某些部分*

## 路由及其配置

无论使用哪种路由器，都必须进行一些*事先的配置*，必须通过配置项来指定路由器在*用户导航时的响应策略*

一些通用的概念：

- 名称 - 单独指定名称或者将路径看作名称
- 动词 - HTTP协议中的动词或其他一些框架自定义的动词
- 路径 - URL的匹配规则
- 功能 - 可能执行的相关代码，如控制器或回调函数
- 视图 - 大部分是到HTML某部分的路径，路由器会处理它的显示
- 参数 - 定义在url中，通过特殊语法进行传入和提取的变量

## 客户端路由器的工作机制

基本特性：

- 通过路由定义的路径来*匹配URL模式*
- 当匹配成功时允许应用程序*执行代码*
- 当路由触发时允许*指定具体视图*
- 允许通过路由*路径传入参数*
- 允许用户使用标准的*浏览器导航*方法来控制

### 片段标识符

- 片段标识符可以是*任意文本*，在url中以*#为前缀*
- 片段标识符通常作为文档*某部分*的引用
- 当片段标识符变化时，html页面*不会刷新*
- 通过location对象的*onhashchange*事件来触发路由匹配以及后续动作

### HTML5的历史API

由于HTML5的历史API并不被所有浏览器兼容，大部分的路由器都默认支持*优雅降级到片段标识符*

- pushState() - 添加新的历史条目
- replaceState() - 替换已有的历史条目
- popstate事件 - 监听state变化

大部分路由器的实现方式：

- 允许选择HTML5的历史API或者片段标识符
- 需要在index.html中配置*基准连接*，与*部署路径*保持一致

```html
<head>
    <base href="/SPA/">
</head>
```

> href 用于文档中相对 URL 地址的基础 URL。如果指定了该属性，这个元素必须写在其他任何属性值是 URL 的元素之前。允许绝对和相对URL（但是请查看下面的注意节段）。

- 服务端需要进行配置，使其能够为*跟路径*返回数据
- 支持路由连接的配置

# 视图合成与布局

在之前的讨论中，主要集中在*单点概念*上，接下来我们将从整个应用的*设计过程*来分析整个SPA应用的设计。

## 布局设计相关概念

### 视图

- 视图是创建整个SPA应用完整*拼图*时的*每个小部分*
- 每个部分为用户提供*特定的功能*，显示数据或是提供输入
- 在视图内部，聚焦于*数据显示、交互*等具体任务
- 从整体视角，需要关注*视图间的定位等*

### Region

- 通过Region来组织界面的整体结构
- 屏幕上包含一个或多个视图的某个区域
- 使用HTML5的语义化标签或者普通的div元素来表示

### 视图合成

- 在Region中*布置视图*以及实现*具体布局*的过程
- Region与视图如何布置完全是*主观*的，根据项目目标和个人喜好进行抉择

### 嵌套视图

- 面对复杂的应用，在视图内再次划分区域，并继续划分视图
- 会大大增加设计的复杂度
- 对于复杂的Region或视图划分，我们经常需要借助框架提供的能力，才能够进行管理

### 应用程序的设计过程

- 确定基本功能范围
- 设计基本布局，划分应用的整体结构
- 设计基本内容，从固定内容开始，例如标题、导航、页脚
- 设计基本的路由
- 深入到具体视图，逐步完善功能

# 模块间交互

尽管我们已经掌握了模块的基本构造方式，将应用程序分隔为很多易于维护的独立单元。但是经常随着项目的发展，项目的整体复杂度依然无法控制。

关键就在于模块之间的*交互方式*，孤立的模块没有任何意义，如果我们没有对模块间的关系进行有效管理，依然会使得我们很快的陷入泥团。

SPA架构存在一个核心的原则：*以单一目的作为设计出发点*

模块间的交互主要有两种方式：

## 通过公开API提供访问

- 消费者直接调用提供者发布出来的API
- 造成模块之间的直接依赖
- 优点是：*简单直接*、*容易调试*
- 缺点是：*耦合度增加*，容易出现*过深的依赖树*和*交叉依赖*关系

## 通过发布/订阅模式进行交互

- 引入一个*中间服务*作为来维护订阅和发布信息
- 通过订阅、发布、退订等接口来传递消息
- 优点是：*松耦合*、*易于实现*、*能够支持一对多的通知*、*消费者容易对消息进行选择*
- 缺点是：*引入额外的依赖*、*事件总是单向流动*、*需要通过命名规范来管理*

# 与服务器端通信

在客户端，我们聚焦与框架如何*简化*与服务器的通信

各种框架都会基于XHR进行扩展，对API进行*简化*，并且提供*功能扩展*

## 一些通用的概念

- 请求的*数据类型*：JSON、XML、表单、或是文件
- HTTP请求方法：充分利用GET、POST、PUT、DELETE提供的语义化表达，以及响应状态码提供的支持
- 数据转换：将JS原生对象与请求所需数据之间的转换和解析

## 基于MV*框架

### 请求生成
- 通常，MV*框架都会基于XHR进行封装，提供友好和简化的API
- 在一些框架中，通过*扩展内置对象*，能够更方便的获取请求相关的功能支持，比如Backbone的Model
- 还有一些框架，使用*独立数据源*来生成请求

### 通过回调函数处理结果
- 请求通常都是异步的
- 通过将回调函数传入请求函数，当获得服务端返回时继续执行
- 通过不同的回调函数来处理请求、错误等不同的请求结果

### 通过Promise处理结果

Promise的三种状态：

- 成功（Fullfilled） - 处理成功，并且包含处理结果
- 失败（Rejected）- 处理失败，包含错误信息
- 待决（Pending）- 处理过程完成之前的状态

通过Promise对象：
- 能够实现*扁平*的代码结构
- 能够进行*链式*处理过程

# 单元测试

单元测试能够帮助我们：
- 发现问题
- 明确需求
- 审视设计
- 增强修改和重构时的信心

构建单元测试，我们应该：
- 保持专注与特定问题
- 应该有明确的目的
- 应当保持独立
- 测试本身应该具备良好的可读性

通常，对*自动化测试*的支撑是现代MV*框架的基本组成部分，借助框架支持，能够快速、简单的实现各个组成部分的测试工作。包括：

- DOM或虚拟DOM创建方式
- 各种组成部分（路由、视图等）的创建、更新、交互过程
- 测试结果的验证方法
- 异步事务的测试方案
- Mock方案以及服务端代理方案
- 完整的测试工具集和相关指导书

# 客户端任务自动化

在开发过程中，我们需要借助Task Runner工具来完成一些重复的、繁琐的、通用的处理过程：

## 开发阶段

- 即时刷新JS和CSS代码，辅助功能调试
- 运行JavaScript和CSS预处理器
- 代码分析
- 持续单元测试

## 构建阶段

- 运行JS和CSS预处理器
- 文件串联（合并）
- 代码压缩
- 持续集成

## Task Runner的选择

目前存在众多的工具帮助我们完成自动化任务，在进行选择时，可以从以下几个角度进行考虑：

- 任务创建方式 - 主要从个人喜好和团队背景来考虑
- 处理过程或方式 - 使用临时文件还是I/O流
- 插件数量 - 是否有足够的工具完成我们日常所需
- 社区 - 任务管理工作通常繁琐而且复杂，需要有便捷的方式帮助我们获取帮助

